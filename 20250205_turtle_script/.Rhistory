OR.data <- read.csv("chemo_counts.csv", header = TRUE, row.names = 1)   #first column is row names; must use row names
#Reading in OR data csv for all species
OR.data <- read.csv("chemo_counts.csv", header = TRUE, row.names = 1)   #first column is row names; must use row names
#selecting for turtles
turtles <- as.data.frame(OR.data[which(OR.data$Order.ry == "Testudines"),])
View(turtles)
#selecting for turtles
turtles <- as.data.frame(OR.data[which(OR.data$Order.ry == "Testudines"),])    #subsetting for the order of testudines, colloquially turtles
max_value_chemo <- rownames(turtles)[which.max(turtles$Chemo.Total)]     #gives which turtle species(rowname) has the most chemo receptors
z <- as.data.frame(cbind(turtles$Family.lry, turtles$OR.gamma))          #cbind combines columns of choice
rownames(z) <- rownames(turtles)  #even though we no longer have species column this will correctly name the species
colnames(z) <- c("Family", "turtle.gamma")     #names the columns; replaces v1 and v2 column names
z$Order <- as.factor(z$Order)
z <- as.data.frame(cbind(turtles$Family.lry, turtles$OR.gamma))          #cbind combines columns of choice
rownames(z) <- rownames(turtles)  #even though we no longer have species column this will correctly name the species
colnames(z) <- c("Family", "turtle.gamma")     #names the columns; replaces v1 and v2 column names
z$Order <- as.factor(z$Order)
View(z)
#Plotting stuff
p <- ggplot(z, aes(Family, turtle.gamma))
p +geom_boxplot() +coord_flip() +theme_bw()
#Reading in OR data csv for all species
OR.data <- read.csv("Dino_OR_Taxa_Corrected_6_25_25_edit.csv", header = TRUE, row.names = 1)   #first column is row names; must use row names
#Reading in OR data csv for all species
OR.data <- read.csv("Dino_OR_Taxa_Corrected_6_25_25_edit.csv", header = TRUE, row.names = 1)   #first column is row names; must use row names
#Reading in OR data csv for all species
OR.data <- read.csv("Dino_OR_Taxa_Corrected_6_25_25_edit.csv", header = TRUE, row.names = 1)   #first column is row names; must use row names
View(OR.data)
View(OR.data)
#Reading in OR data csv for all species
OR.data <- read.csv("Dino_OR_Taxa_Corrected_6_25_25_edit.csv", header = TRUE, row.names = 2)   #first column is row names; must use row names
View(OR.data)
#Reading in OR data csv for all species
OR.data <- read.csv("Dino_OR_Taxa_Corrected_6_25_25_edit.csv", header = TRUE, row.names = 1)   #first column is row names; must use row names
View(OR.data)
rownames(my_data) <- gsub(".collapsed.fasta", "", rownames(OR.data))  #removing collapsed.fasta from the rownames
rownames(OR.data) <- gsub(".collapsed.fasta", "", rownames(OR.data))  #removing collapsed.fasta from the rownames
View(OR.data)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
View(turtle.tree)
library(dplyr)
library(rentrez)
install.packages("rentrez")
library(rentrez)
#Getting turtle data from NCBI
get_ncbi_genome_info <- function(tax_name) {
# Search NCBI Taxonomy for the given taxon name
tax_id <- entrez_search(db = "taxonomy", term = tax_name)$ids
if (length(tax_id) == 0) {
print(paste("No taxonomy ID found for", tax_name))
return(NULL) # Return NULL if no ID is found
}
# Search NCBI Genome for assemblies under the given taxon ID
genome_search_term <- paste0(tax_id[1], "[Taxonomy ID] AND complete genome[Properties]") # Restrict to complete genomes
genome_ids <- entrez_search(db = "assembly", term = genome_search_term, retmax = 5000)$ids # Adjust retmax if needed
if (length(genome_ids) == 0) {
print(paste("No genomes found for", tax_name))
return(NULL)
}
genome_info <- data.frame()
for (id in genome_ids) {
# Fetch summary information for each genome assembly
summary <- entrez_summary(db = "assembly", id = id)
# Extract relevant information (handle potential missing data)
scientific_name <- summary$scientificname
assembly_id <- summary$assemblyaccession
genbank_id <- ifelse(!is.null(summary$genbank), summary$genbank, NA) # Handle missing GenBank ID
refseq_id <- ifelse(!is.null(summary$refseq), summary$refseq, NA)     # Handle missing RefSeq ID
genome_info <- rbind(genome_info, data.frame(
scientific_name = scientific_name,
assembly_id = assembly_id,
genbank_id = genbank_id,
refseq_id = refseq_id
))
}
return(genome_info)
}
# Get genome information for Testudines
testudines_info <- get_ncbi_genome_info("Testudines")
# Get genome information for Testudines
testudines_info <- get_ncbi_genome_info("Testudines (anapsid reptiles)")
# Get genome information for Testudines
testudines_info <- get_ncbi_genome_info("Testudines")
rm testudines_info
rm(testudines_info)
rm(get_ncbi_genome_info())
rm(get_ncbi_genome_info
View(get_ncbi_genome_info)
rm(get_ncbi_genome_info)
#getting genome information from ncbi
get_ncbi_genome_info <- function(tax_name) {
tax_id <- entrez_search(db = "taxonomy", term = tax_name)$ids
if (length(tax_id) == 0) {
print(paste("No taxonomy ID found for", tax_name))
return(NULL)
}
genome_search_term <- paste0(tax_id[1], "[Taxonomy ID]") # Search all genomes (not just complete)
# Get total number of genomes to retrieve them in batches (important for large datasets)
search_count <- entrez_search(db = "assembly", term = genome_search_term, retmax = 1)$count
all_genome_info <- data.frame()
batch_size <- 500  # NCBI's default retmax
for (start in seq(0, search_count, by = batch_size)) {
genome_ids <- entrez_search(db = "assembly", term = genome_search_term, retmax = batch_size, start = start)$ids
if (length(genome_ids) == 0) break # No more results
batch_info <- data.frame()
for (id in genome_ids) {
summary <- entrez_summary(db = "assembly", id = id)
# Enhanced extraction to handle lists and missing data:
extract_info <- function(field) {
if (is.null(summary[[field]])) {
return(NA)
} else if (is.list(summary[[field]])) {
paste(unlist(summary[[field]]), collapse = "; ") # Collapse lists to strings
} else {
summary[[field]]
}
}
scientific_name <- extract_info("scientificname")
assembly_id <- extract_info("assemblyaccession")
genbank_id <- extract_info("genbank")
refseq_id <- extract_info("refseq")
taxid <- extract_info("taxid")
organism_name <- extract_info("organismname")
infraspecific_name <- extract_info("infraspecificname")
bioproject <- extract_info("bioproject")
biosample <- extract_info("biosample")
status <- extract_info("status")
submitter <- extract_info("submitter")
batch_info <- rbind(batch_info, data.frame(
scientific_name = scientific_name,
assembly_id = assembly_id,
genbank_id = genbank_id,
refseq_id = refseq_id,
taxid = taxid,
organism_name = organism_name,
infraspecific_name = infraspecific_name,
bioproject = bioproject,
biosample = biosample,
status = status,
submitter = submitter
))
}
all_genome_info <- rbind(all_genome_info, batch_info)
Sys.sleep(0.5) # Be respectful of NCBI's rate limits (adjust as needed)
}
return(all_genome_info)
}
testudines_info <- get_ncbi_genome_info("Testudines")
View(testudines_info)
if (!is.null(testudines_info)) {
print(head(testudines_info))  # Print the first few rows
print(paste("Total genomes found:", nrow(testudines_info)))
write.csv(testudines_info, file = "testudines_genomes_all.csv", row.names = FALSE) # Save to CSV
}
View(get_ncbi_genome_info)
View(get_ncbi_genome_info)
View(get_ncbi_genome_info)
rm(get_ncbi_genome_info)
rm(testudines_info)
View(turtle.tree)
View(turtle.tree)
turtle.tree[["tip.label"]]
get_testudines_scientific_names <- function(n = 85) { # n is the number of names to retrieve
tax_id <- entrez_search(db = "taxonomy", term = "Testudines")$ids
if (length(tax_id) == 0) {
print("No taxonomy ID found for Testudines")
return(NULL)
}
genome_search_term <- paste0(tax_id[1], "[Taxonomy ID]")
# Get total number of genomes to retrieve them in batches
search_count <- entrez_search(db = "assembly", term = genome_search_term, retmax = 1)$count
if (search_count == 0) {
print("No genomes found for Testudines")
return(NULL)
}
if (n > search_count) {
print(paste("Requested", n, "genomes, but only", search_count, "found. Returning all found genomes."))
n<- search_count
}
all_scientific_names <- character(0) # Initialize an empty character vector
batch_size <- 500 # NCBI's default retmax
genomes_retrieved <- 0
for (start in seq(0, search_count, by = batch_size)) {
if (genomes_retrieved >= n) break # Stop if we've retrieved enough
genome_ids <- entrez_search(db = "assembly", term = genome_search_term, retmax = batch_size, start = start)$ids
if (length(genome_ids) == 0) break # No more results
for (id in genome_ids) {
if (genomes_retrieved >= n) break # Inner loop break
summary <- entrez_summary(db = "assembly", id = id)
scientific_name <- summary$scientificname
if (!is.null(scientific_name)) { # Check if name is available
all_scientific_names <- c(all_scientific_names, scientific_name)
genomes_retrieved <- genomes_retrieved + 1
}
}
Sys.sleep(0.5) # Be respectful of NCBI's rate limits
}
return(all_scientific_names[1:n]) # Return only the requested number of names
}
testudines_names <- get_testudines_scientific_names(85) # Get 85 names (or fewer if there are fewer genomes)
rm(testudines_names)
rm(get_testudines_scientific_names())
rm(get_testudines_scientific_names
)
entrez?
?ncbi
?entrez
??entrez
man(treedata)
?treedata
View(OR.data)
?read.delim
#Loading in table of all turtle genomes on NCBI
testudines_genomes <- read.delim("ncbi_testudines_genome.tsv", sep = "\t")
View(testudines_genomes)
View(testudines_genomes)
View(testudines_genomes)
View(testudines_genomes)
View(testudines_genomes)
View(OR.data)
View(OR.data)
View(OR.data)
#preparing to merge the OR data and the table of testudines genomes
colname(OR.data[,1]) <- "Organism.Name"
#preparing to merge the OR data and the table of testudines genomes
OR.data <- OR.data %>% rename(Organism.Name = FirstColumn)
#preparing to merge the OR data and the table of testudines genomes
OR.data <- OR.data %>% rename(Organism.rowname = Ogranism.Name)
#preparing to merge the OR data and the table of testudines genomes
names(OR.data)[1] <- "Organism.Name"
View(OR.data)
View(testudines_genomes)
# 1. Select the desired columns from testudines_genomes
testudines_genomes_subset <- testudines_genomes[, c("Organism.Name", "Assembly.Name", "Assembly.Accession", "Assembly.level")]
# 1. Select the desired columns from testudines_genomes
testudines_genomes_subset <- testudines_genomes[, c("Organism.Name", "Assembly.Name", "Assembly.Accession", "Assembly.level")]
colnames(testudines_genomes)
# 1. Select the desired columns from testudines_genomes
testudines_genomes_subset <- testudines_genomes[, c("Organism.Name", "Assembly.Name", "Assembly.Accession", "Assembly.Level")]
testudines_genomes_subset <- testudines_genomes %>%
select(Organism.Name, Assembly.Name, Assembly.Accession, Assembly.level)
testudines_genomes_subset <- testudines_genomes %>%
select(Organism.Name, Assembly.Name, Assembly.Accession, Assembly.Level)
View(testudines_genomes_subset)
# 2. Merge the data frames using merge() (base R)
merged_data <- merge(OR.data, testudines_genomes_subset, by = "Organism.Name", all.x = TRUE)
View(merged_data)
# OR, using dplyr::left_join() (recommended):
merged_data <- OR.data %>%
left_join(testudines_genomes_subset, by = "Organism.Name")
View(merged_data)
merged_data <- merged_data %>% relocate(Organism.Name, .before = everything()) #using dplyr
View(merged_data)
View(merged_data)
# 1. Select the desired columns from testudines_genomes (same as before)
testudines_genomes_subset <- testudines_genomes[, c("Organism.Name", "Assembly.Name", "Assembly.Accession", "Assembly.Level")]
testudines_genomes_subset <- testudines_genomes %>%
select(Organism.Name, Assembly.Name, Assembly.Accession, Assembly.Level)
# 2. Merge using inner_join() to keep only matching rows
merged_data <- OR.data %>%
inner_join(testudines_genomes_subset, by = "Organism.Name")
# 2. Merge using inner_join() to keep only matching rows
merged_data <- OR.data %>%
inner_join(testudines_genomes_subset, by = "Organism.Name")
merged_data <- merged_data %>% relocate(Organism.Name, .before = everything()) #reformatting for readability. Organism.Name in first column
View(merged_data)
# 1. Select the desired columns from testudines_genomes (same as before)
testudines_genomes_subset <- testudines_genomes[, c("Organism.Name", "Assembly.Name", "Assembly.Accession", "Assembly.Level")]
testudines_genomes_subset <- testudines_genomes %>%
select(Organism.Name, Assembly.Name, Assembly.Accession, Assembly.Level)
# 2. Merge using inner_join() to keep only matching rows
merged_data <- OR.data %>%
inner_join(testudines_genomes_subset, by = "Organism.Name")
View(OR.data)
matching_names <- intersect(OR.data$Organism.Name, testudines_genomes$Organism.Name)
num_matching <- length(matching_names)
testudines_genomes$Organism.Name <- gsub(" ", "_", testudines_genomes$Organism.Name)
# 1. Select the desired columns from testudines_genomes (same as before)
testudines_genomes_subset <- testudines_genomes[, c("Organism.Name", "Assembly.Name", "Assembly.Accession", "Assembly.Level")]
testudines_genomes_subset <- testudines_genomes %>%
select(Organism.Name, Assembly.Name, Assembly.Accession, Assembly.Level)
# 2. Merge using inner_join() to keep only matching rows
merged_data <- OR.data %>%
inner_join(testudines_genomes_subset, by = "Organism.Name")
merged_data <- merged_data %>% relocate(Organism.Name, .before = everything()) #reformatting for readability. Organism.Name in first column
View(merged_data)
View(merged_data)
# Merge using inner_join() to keep only matching rows
merged_OR.data <- OR.data %>%
inner_join(testudines_genomes_subset, by = "Organism.Name")
merged_OR.data <- merged_data %>% relocate(Organism.Name, .before = everything()) #reformatting for readability. Organism.Name in first column
rm(merged_data)
View(merged_OR.data)
merged_OR.data <- merged_OR.data[,!names("MIXEDCLUSTER")]
?treedata
treedata(turtle.tree, merged_OR.data, sort = FALSE, warnings = TRUE)
merged_match_tree <-treedata(turtle.tree, merged_OR.data, sort = FALSE, warnings = TRUE)
View(merged_match_tree)
merged_match_tree <-treedata(turtle.tree, merged_OR.data, sort = TRUE, warnings = FALSE)
View(merged_match_tree)
merged_match_tree <-treedata(turtle.tree, merged_OR.data, sort = FALSE, warnings = FALSE)
View(merged_match_tree)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
View(OR.data)
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy
View(turtle.tree)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
View(turtle.tree)
View(turtle.tree)
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
View(turtle.tree)
View(turtle.tree)
plot(turtle.tree)
turtle.tree
tree_names <- turtle.tree$tip.label
matching_names_unique <- intersect(tree_names, OR.data$Organism.Name)
length(matching_names_unique)
matching_names_unique <- intersect(tree_names, merged_OR.data$Organism.Name)
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
View(turtle.tree)
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
matching_names_unique <- intersect(tree_names, merged_OR.data$Organism.Name)
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
turtle.tree
length(merged_OR.data$Organism.Name)
treedata(turtle.tree, merged_OR.data, sort = T, warning = T)
View(merged_OR.data)
View(turtle.tree)
view(tree_names)
data.frame(tree_names)
tree_names  <- data.frame(tree_names)
View(tree_names)
View(testudines_genomes)
turtle.tree$tip.label <- gsub("Chrysemys_picta", "Chrysemys_picta_bellii", turtle.tree$tip.label)
tree_names  <- data.frame(tree_names)  #checking names and making them match across datasets
turtle.tree$tip.label <- gsub("Chrysemys_picta", "Chrysemys_picta_bellii", turtle.tree$tip.label)
View(turtle.tree)
turtle.tree[["tip.label"]]
#checking names and making them match across objects
tree_names  <- data.frame(tree_names)
View(tree_names)
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
View(tree_names)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
matching_names_unique <- intersect(tree_names, merged_OR.data$Organism.Name)
matching_names_unique <- intersect(tree_names, merged_OR.data$Organism.Name)
matching_names_unique <- intersect(tree_names, merged_OR.data$Organism.Name)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
matching_names_unique <- intersect(tree_names, merged_OR.data$Organism.Name)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
turtle.tree$tip.label <- gsub("Chrysemys_picta", "Chrysemys_picta_bellii", turtle.tree$tip.label)
View(tree_names)
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
df_no_duplicates <- df[!duplicated(df), ] #removing duplicates
merged_OR.data <- merged_OR.data[!duplicated(merged_OR.data), ] #removing duplicates
View(merged_OR.data)
# Merge using inner_join() to keep only matching rows
merged_OR.data <- OR.data %>%
inner_join(testudines_genomes_subset, by = "Organism.Name")
merged_OR.data <- merged_data %>% relocate(Organism.Name, .before = everything()) #reformatting for readability. Organism.Name in first column
merged_OR.data <- merged_OR.data %>% distinct() #removing duplicates
View(merged_OR.data)
testudines_all_species <- read.csv("all_testudines_species.csv")
View(testudines_all_species)
testudines_all_species <- colnames(testudines_all_species)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
View(tree_names)
turtle.tree <- treedata(turtle.tree, testudines_all_species, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data
View(OR.data)
View(merged_OR.data)
View(OR.data)
View(OR.data)
#filtering OR.data for turtle species
turtle_OR <- OR.data[grep(paste0("^(", paste(testudines_all_species, collapse = "|"), ")(_|$)"), OR.data$Organism.Name), ]
View(turtle_OR)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
turtle_OR$Organism.Name <- stringr::str_extract(turtle_OR$Organism.Name, "[^_]+_[^_]+")
turtle.tree <- treedata(turtle.tree, turtle_OR, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
View(tree_names)
View(turtle_OR)
View(tree_names)
intersect(turtle_OR$Organism.Name, tree_names$turtle.tree.tip.label)
turtle.tree$tip.label <- intersect(turtle_OR$Organism.Name, tree_names$turtle.tree.tip.label)
plot(turtle.tree)
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
plot(turtle.tree)
turtle.tree <- treedata(turtle.tree, turtle_OR, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
plot turtle.tree
plot(turtle.tree)
View(turtle.tree)
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
#filtering OR.data for turtle species
turtle_OR <- OR.data[grep(paste0("^(", paste(testudines_all_species, collapse = "|"), ")(_|$)"), OR.data$Organism.Name), ]
turtle_OR$Organism.Name <- stringr::str_extract(turtle_OR$Organism.Name, "[^_]+_[^_]+")    #gets rid of the subpopulation name for matching purposes
View(turtle_OR)
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
rownames(OR.data) <- OR.data$Organism.Name
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
rownames(OR.data) <- OR.data$Organism.Name
View(OR.data)
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
View(turtle.tree)
View(OR.data)
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
rownames(OR.data) <- OR.data$Organism.Name
turtle.tree <- treedata(turtle.tree, OR.data, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
###Phylogenetic Tree In Following Code
turtle.tree <- read.tree("tetrapod_tree_grafted_forTurtles.tre")
turtle.tree <- ladderize(turtle.tree)
turtle.tree <- multi2di(turtle.tree, random = TRUE)
turtle.tree$edge.length[turtle.tree$edge.length==0.0] <- 0.1     #resolves troublesome nodes at random; can check if successful w/ internal nodes = n-1
#filtering OR.data for turtle species
turtle_OR <- OR.data[grep(paste0("^(", paste(testudines_all_species, collapse = "|"), ")(_|$)"), OR.data$Organism.Name), ]
turtle_OR$Organism.Name <- stringr::str_extract(turtle_OR$Organism.Name, "[^_]+_[^_]+")    #gets rid of the subpopulation name for matching purposes
#checking names and making them match across objects
tree_names  <- data.frame(turtle.tree$tip.label)
View(OR.data)
View(tree_names)
intersect(turtle.tree$tip.label, rownames(OR.data))
?treedata
turtle.tree <- treedata(turtle.tree, rownames(OR.data), sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
intersect(turtle.tree$tip.label, rownames(OR.data), testudines_all_species)
intersect(turtle.tree$tip.label, rownames(OR.data), dataframe(testudines_all_species))
data.frame(testudines_all_species)
testudines_all_species.df <- data.frame(testudines_all_species)
View(testudines_all_species.df)
intersect(turtle.tree$tip.label, rownames(OR.data), testudines_all_species.df[,1])
intersect(turtle.tree$tip.label, rownames(OR.data), testudines_all_species.df$testudines_all_species)
intersect(turtle.tree$tip.label, testudines_all_species.df$testudines_all_species)
intersect(rownames(OR.data), testudines_all_species.df$testudines_all_species)
View(turtle_OR)
turtle.tree <- treedata(turtle.tree, turtle_OR, sort = T, warning = T)$phy                 #matches the tree and the dataset. $phy grabs the data. Couldn't get this to work
turtle.tree.data <- treedata(turtle.tree, turtle_OR, sort = T, warning = T)$data
turtle.tree.data <- as.data.frame(turtle.tree.data)   #always check trough data to see if things are spelled correctly and make sure you get the maximum entries
View(turtle.tree.data)
plot(turtle.tree)
plot(turtle.treedata)
plot(turtle.tree)
